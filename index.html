<script>
  function linkify(text) {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    return String(text || "").replace(urlRegex, (url) => {
      return '<a href="' + url + '" target="_blank" rel="noopener" ' +
        'style="color:#38bdf8; text-decoration:underline;">' + url + '</a>';
    });
  }

  const WEBHOOK_URL = "https://n8n.co-workerhou.se/webhook/public-chatbot";
  const chatBody = document.getElementById("chatBody");
  const chatInput = document.getElementById("chatInput");
  const sendBtn = document.getElementById("sendBtn");
  const sendLabel = document.getElementById("sendLabel");

  // ✅ 기존처럼 단순 랜덤 세션 (localStorage 안 씀)
  const sessionId = "sess_" + Math.random().toString(36).slice(2);

  function addMessage(text, role) {
    const row = document.createElement("div");
    row.className = "row " + role;

    const bubble = document.createElement("div");
    bubble.className = "bubble " + role;
    bubble.innerHTML = linkify(text);

    row.appendChild(bubble);
    chatBody.appendChild(row);
    chatBody.scrollTop = chatBody.scrollHeight;
    return bubble; // 나중에 업데이트용
  }

  function setLoading(b) {
    sendBtn.disabled = b;
    sendLabel.textContent = b ? "답변 생성 중..." : "전송";
  }

  function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function fetchWithTimeout(url, options, timeoutMs) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, Object.assign({}, options, { signal: controller.signal, cache: "no-store" }));
      const raw = await res.text();
      return { res, raw };
    } finally {
      clearTimeout(timer);
    }
  }

  async function sendMessage(text) {
    const q = (text || "").trim();
    if (!q) return;

    addMessage(q, "user");
    setLoading(true);

    // ✅ 재시도용 requestId (서버가 무시해도 됨)
    const requestId = "req_" + Date.now() + "_" + Math.random().toString(36).slice(2);
    const payload = { message: q, sessionId: sessionId, requestId: requestId };

    const botBubble = addMessage("답변 생성 중… (최대 30초)\n연결이 끊기면 자동 재시도합니다.", "bot");

    const MAX_ATTEMPTS = 4;
    const TIMEOUT_MS = 35000;

    for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
      try {
        botBubble.innerHTML = linkify("답변 생성 중… (" + attempt + "/" + MAX_ATTEMPTS + ")");

        const result = await fetchWithTimeout(
          WEBHOOK_URL,
          {
            method: "POST",
            headers: { "Content-Type": "application/json", "Accept": "application/json" },
            body: JSON.stringify(payload),
            credentials: "omit",
          },
          TIMEOUT_MS
        );

        const res = result.res;
        const raw = result.raw;

        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText + "\n" + raw.slice(0, 200));

        let data;
        try { data = JSON.parse(raw); }
        catch (e) { throw new Error("NOT_JSON\n" + raw.slice(0, 200)); }

        const answer = (data && data.answer) ? data.answer : "답변을 불러오지 못했어요. 잠시 후 다시 시도해 주세요.";
        botBubble.innerHTML = linkify(answer);
        setLoading(false);
        return;

      } catch (e) {
        const msg = String(e && e.message ? e.message : e);
        const networky =
          msg.indexOf("AbortError") >= 0 ||
          msg.indexOf("Failed to fetch") >= 0 ||
          msg.indexOf("NetworkError") >= 0 ||
          msg.indexOf("Load failed") >= 0;

        if (attempt === MAX_ATTEMPTS || !networky) {
          botBubble.innerHTML = linkify("네트워크 오류가 발생했어요. 다시 시도해 주세요.\n(디버그: " + msg.slice(0, 120) + "…)");
          setLoading(false);
          return;
        }

        const backoff = Math.min(800 * Math.pow(2, attempt - 1), 6000);
        botBubble.innerHTML = linkify("연결이 잠시 끊겼어요. " + Math.ceil(backoff / 1000) + "초 후 재시도합니다…");
        await sleep(backoff);
      }
    }

    setLoading(false);
  }

  // ✅ 초기 인사말(네 기존 그대로)
  addMessage(
    "안녕하세요. 오늘의집 큐레이터 챗봇입니다.\n" +
    "큐레이터 활동, 링크 발급, 정산 등 궁금한 내용을 편하게 물어보세요 :)\n" +
    "(답변까지 약 10초 소요)",
    "bot"
  );

  sendBtn.addEventListener("click", () => {
    const text = chatInput.value;
    chatInput.value = "";
    sendMessage(text);
  });

  let isComposing = false;
  chatInput.addEventListener("compositionstart", () => (isComposing = true));
  chatInput.addEventListener("compositionend", () => (isComposing = false));

  chatInput.addEventListener("keydown", (e) => {
    if (isComposing) return;
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const text = chatInput.value;
      chatInput.value = "";
      sendMessage(text);
    }
  });
</script>
